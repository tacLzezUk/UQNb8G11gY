function [dX] = ode_3dinputDIPC_wiener(state_vars, u, M, m1, m2, l1, l2, g, noise_magnit)
%ode_3dinputDIPC_wiener system of ODEs for double inverted pendulum on a cart
% with Gaussian white noise (Wiener process).
%   The inputs to this system include the force to a cart and the torque to
%   the first and second joint. 

dX = zeros(6, 1);


dX(1, 1) = state_vars(4, 1);
dX(4, 1) = (l1*m1*u(3)*cos(2*state_vars(2) - state_vars(3)) + ...
    l1*m2*u(3)*cos(2*state_vars(2) - state_vars(3)) + 2*l1*l2*m1*u(1) + l1*l2*m2*u(1) - ...
    2*l2*m1*u(2)*cos(state_vars(2)) - l1*m1*u(3)*cos(state_vars(3)) - l2*m2*u(2)*cos(state_vars(2)) - ...
    l1*m2*u(3)*cos(state_vars(3)) + l2*m2*u(2)*cos(state_vars(2) - 2*state_vars(3)) + ...
    2*l1^2*l2*m1^2*state_vars(5)^2*sin(state_vars(2)) - l1*l2*m2*u(1)*cos(2*state_vars(2) - 2*state_vars(3)) - ...
    g*l1*l2*m1^2*sin(2*state_vars(2)) + 2*l1^2*l2*m1*m2*state_vars(5)^2*sin(state_vars(2)) + ...
    l1*l2^2*m1*m2*state_vars(6)^2*sin(state_vars(3)) + ...
    l1*l2^2*m1*m2*state_vars(6)^2*sin(2*state_vars(2) - state_vars(3)) - ...
    g*l1*l2*m1*m2*sin(2*state_vars(2)))/(l1*l2*(2*M*m1 + M*m2 + m1*m2 - m1^2*cos(2*state_vars(2)) + ...
    m1^2 - m1*m2*cos(2*state_vars(2)) - M*m2*cos(2*state_vars(2) - 2*state_vars(3))));

dX(2, 1) = state_vars(5, 1);
dX(5, 1) = -(2*M*l1*u(3)*cos(state_vars(2) - state_vars(3)) - 2*l2*m1*u(2) - l2*m2*u(2) - ...
    l1*m1*u(3)*cos(state_vars(2) + state_vars(3)) - l1*m2*u(3)*cos(state_vars(2) + state_vars(3)) - ...
    2*M*l2*u(2) + l1*m1*u(3)*cos(state_vars(2) - state_vars(3)) + l1*m2*u(3)*cos(state_vars(2) - state_vars(3)) + ...
    l2*m2*u(2)*cos(2*state_vars(3)) - l1*l2*m2*u(1)*cos(state_vars(2) - 2*state_vars(3)) - ...
    2*g*l1*l2*m1^2*sin(state_vars(2)) + l1^2*l2*m1^2*state_vars(5)^2*sin(2*state_vars(2)) + ...
    2*l1*l2*m1*u(1)*cos(state_vars(2)) + l1*l2*m2*u(1)*cos(state_vars(2)) + ...
    2*M*l1*l2^2*m2*state_vars(6)^2*sin(state_vars(2) - state_vars(3)) - 2*M*g*l1*l2*m1*sin(state_vars(2)) - ...
    M*g*l1*l2*m2*sin(state_vars(2)) + l1*l2^2*m1*m2*state_vars(6)^2*sin(state_vars(2) - state_vars(3)) - ...
    2*g*l1*l2*m1*m2*sin(state_vars(2)) - M*g*l1*l2*m2*sin(state_vars(2) - 2*state_vars(3)) + ...
    l1^2*l2*m1*m2*state_vars(5)^2*sin(2*state_vars(2)) + M*l1^2*l2*m2*state_vars(5)^2*sin(2*state_vars(2) - 2*state_vars(3)) + ...
    l1*l2^2*m1*m2*state_vars(6)^2*sin(state_vars(2) + state_vars(3)))/(l1^2*l2*(2*M*m1 + M*m2 + m1*m2 - ...
    m1^2*cos(2*state_vars(2)) + m1^2 - m1*m2*cos(2*state_vars(2)) - M*m2*cos(2*state_vars(2) - 2*state_vars(3))));

dX(3, 1) = state_vars(6, 1);
dX(6, 1) = (l1*m1^2*u(3) + l1*m2^2*u(3) - l2*m2^2*u(2)*cos(state_vars(2) - state_vars(3)) + 2*l1*m1*m2*u(3) - ...
    l1*m1^2*u(3)*cos(2*state_vars(2)) - l1*m2^2*u(3)*cos(2*state_vars(2)) + l2*m2^2*u(2)*cos(state_vars(2) + state_vars(3)) + ...
    2*M*l1*m1*u(3) + 2*M*l1*m2*u(3) - 2*M*l2*m2*u(2)*cos(state_vars(2) - state_vars(3)) - ...
    l2*m1*m2*u(2)*cos(state_vars(2) - state_vars(3)) - l1*l2*m2^2*u(1)*cos(state_vars(3)) - ...
    2*l1*m1*m2*u(3)*cos(2*state_vars(2)) + l2*m1*m2*u(2)*cos(state_vars(2) + state_vars(3)) + ...
    l1*l2*m2^2*u(1)*cos(2*state_vars(2) - state_vars(3)) - M*g*l1*l2*m2^2*sin(2*state_vars(2) - state_vars(3)) - ...
    l1*l2*m1*m2*u(1)*cos(state_vars(3)) + 2*M*l1^2*l2*m2^2*state_vars(5)^2*sin(state_vars(2) - state_vars(3)) + ...
    M*g*l1*l2*m2^2*sin(state_vars(3)) + l1*l2*m1*m2*u(1)*cos(2*state_vars(2) - state_vars(3)) + ...
    M*l1*l2^2*m2^2*state_vars(6)^2*sin(2*state_vars(2) - 2*state_vars(3)) - ...
    M*g*l1*l2*m1*m2*sin(2*state_vars(2) - state_vars(3)) + 2*M*l1^2*l2*m1*m2*state_vars(5)^2*sin(state_vars(2) - state_vars(3)) + ...
    M*g*l1*l2*m1*m2*sin(state_vars(3)))/(l1*l2^2*m2*(2*M*m1 + M*m2 + m1*m2 - m1^2*cos(2*state_vars(2)) + ...
    m1^2 - m1*m2*cos(2*state_vars(2)) - M*m2*cos(2*state_vars(2) - 2*state_vars(3))));


noise = wgn(1, 6, 0)';

dX = dX + noise_magnit * noise;

end

